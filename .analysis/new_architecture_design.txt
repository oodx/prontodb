====
 ðŸ—ï¸ NEW PRONTODB ARCHITECTURE: PER-ADDRESS KEYSTORES
====
Design Date: 2025-09-21
Status: Initial Design Phase
Target: True multi-agent isolation

====
 ðŸŽ¯ CORE DESIGN PRINCIPLES
====

1. **Address-First Architecture**: Each address gets isolated storage
2. **True Isolation**: No shared state between addresses
3. **Performance**: Direct address routing without namespace overhead
4. **Scalability**: Independent keystore scaling
5. **RSB Compliance**: Maintain string-biased API patterns

====
 ðŸ“ NEW FILESYSTEM STRUCTURE
====

```
~/.local/share/prontodb/
â”œâ”€â”€ addresses/                    â† Per-address isolated keystores
â”‚   â”œâ”€â”€ user1/
â”‚   â”‚   â”œâ”€â”€ cursor1/
â”‚   â”‚   â”‚   â”œâ”€â”€ keystore.db      â† Individual SQLite database
â”‚   â”‚   â”‚   â””â”€â”€ metadata.json    â† Address-specific config
â”‚   â”‚   â”œâ”€â”€ cursor2/
â”‚   â”‚   â”‚   â”œâ”€â”€ keystore.db
â”‚   â”‚   â”‚   â””â”€â”€ metadata.json
â”‚   â”‚   â””â”€â”€ _default/            â† Default cursor when none specified
â”‚   â”‚       â”œâ”€â”€ keystore.db
â”‚   â”‚       â””â”€â”€ metadata.json
â”‚   â”œâ”€â”€ user2/
â”‚   â”‚   â””â”€â”€ cursor1/
â”‚   â”‚       â”œâ”€â”€ keystore.db
â”‚   â”‚       â””â”€â”€ metadata.json
â”‚   â””â”€â”€ _global/                 â† Global shared data (minimal)
â”‚       â””â”€â”€ cursor1/
â”‚           â”œâ”€â”€ keystore.db
â”‚           â””â”€â”€ metadata.json
â”œâ”€â”€ registry/                     â† Address registry and management
â”‚   â”œâ”€â”€ address_registry.db      â† Track all known addresses
â”‚   â”œâ”€â”€ active_sessions.db       â† Track active sessions per address
â”‚   â””â”€â”€ global_config.json       â† System-wide configuration
â””â”€â”€ backups/                     â† Backup management
    â”œâ”€â”€ full/                    â† Complete system backups
    â””â”€â”€ incremental/             â† Per-address incremental backups
```

====
 ðŸ”§ NEW API ARCHITECTURE
====

## Address Resolution Flow
```
CLI Input: --user agent1 --cursor prod set app.config "value"
         â†“
Address Resolution: user=agent1, cursor=prod
         â†“
Path: ~/.local/share/prontodb/addresses/agent1/prod/keystore.db
         â†“
Direct SQLite Operations on isolated database
```

## Storage Layer Interface
```rust
pub struct AddressedStorage {
    pub user: String,
    pub cursor: String,
    pub keystore_path: PathBuf,
    pub connection: Connection,
}

impl AddressedStorage {
    pub fn resolve_address(user: &str, cursor: &str) -> Result<Self>;
    pub fn ensure_keystore_exists(&self) -> Result<()>;
    pub fn set(&self, key: &str, value: &str) -> Result<()>;
    pub fn get(&self, key: &str) -> Result<Option<String>>;
    pub fn delete(&self, key: &str) -> Result<()>;
    pub fn list_keys(&self, prefix: Option<&str>) -> Result<Vec<String>>;
}
```

====
 ðŸ“Š MIGRATION STRATEGY
====

## Phase 1: New Storage Layer (2-3 days)
1. Implement AddressedStorage struct
2. Create address resolution logic
3. Build per-address SQLite management
4. Add keystore lifecycle management

## Phase 2: API Layer Rebuild (2-3 days)
1. Rebuild src/api.rs for address-first routing
2. Update all commands for new storage interface
3. Implement cross-address operations (copy, backup)
4. Add address registry management

## Phase 3: CLI Integration (1-2 days)
1. Update dispatcher for new address resolution
2. Maintain RSB compliance patterns
3. Update help and error messages
4. Add address discovery commands

## Phase 4: Migration & Testing (2-3 days)
1. Create migration tool from old broken format
2. Comprehensive isolation testing
3. Performance benchmarking
4. Multi-agent stress testing

====
 ðŸ’¾ DATA MODEL CHANGES
====

## Old (Broken) Model
```sql
-- Single shared database
CREATE TABLE kvstore (
    id INTEGER PRIMARY KEY,
    address TEXT NOT NULL,  -- user.cursor.namespace.key
    value TEXT NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

## New (Correct) Model
```sql
-- Per-address database schema
CREATE TABLE kvstore (
    id INTEGER PRIMARY KEY,
    namespace_key TEXT NOT NULL,  -- namespace.key only
    value TEXT NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    ttl_expires_at TIMESTAMP,     -- For TTL support
    UNIQUE(namespace_key)
);

CREATE INDEX idx_namespace_key ON kvstore(namespace_key);
CREATE INDEX idx_ttl_expires ON kvstore(ttl_expires_at);
```

====
 ðŸš€ PERFORMANCE IMPLICATIONS
====

## Benefits
- **Direct Routing**: No namespace parsing overhead
- **Parallel Operations**: Independent databases = better concurrency
- **Isolated Locking**: No cross-address lock contention
- **Selective Backup**: Backup only needed addresses
- **True Scaling**: Each address scales independently

## Considerations
- **File Handles**: More SQLite files = more file descriptors
- **Memory Usage**: Multiple connections in memory
- **Disk Space**: Some overhead per keystore
- **Complexity**: Address lifecycle management

====
 ðŸ”’ SECURITY & ISOLATION
====

## True Isolation Guarantees
- **File System Isolation**: Separate database files
- **Process Isolation**: Independent SQLite connections
- **No Shared Memory**: Zero cross-contamination
- **Clear Boundaries**: Address-based permissions

## Security Model
- File permissions per address directory
- Optional encryption per keystore
- Address-based access control
- Audit logging per address

====
 ðŸ§ª TESTING STRATEGY
====

## Isolation Tests
1. Multi-agent concurrent operations
2. Cross-address data verification
3. Performance under concurrent load
4. File system isolation verification

## Migration Tests
1. Old format data preservation
2. Address mapping correctness
3. Data integrity verification
4. Performance comparison

====
 ðŸš¨ CRITICAL SUCCESS FACTORS
====

1. **True Isolation**: Multi-agent workflows must work correctly
2. **Performance**: Must meet or exceed current broken implementation
3. **RSB Compliance**: Maintain string-biased API patterns
4. **Migration**: Clean path from current broken state
5. **Documentation**: Track architectural decision rationale

====